# Переносимая реализация `countof()` средствами C23/C++11

`countof_ns()` это переносимая реализация макроса `countof()` черновика
стандарта C2y средствами стандартов C23/C++11 или с использованием расширений
стандартов языка C предыдущих редакций, которые поддерживаются большинством
компиляторов.

Неполный список поддерживаемых компиляторов: Clang, GNU gcc, IntelLLVM (icx),
MSVC (Visual Studio 2022), NVHPC (NVIDIA HPC Compiler), Pelles C, PGI (The
Portland Group(?)), SunPro (Oracle Developer Studio).

## Содержание

- [Введение](#введение)
- [Установка](#установка)
- [Использование](#использование)
- [Обоснование](#обоснование)
- [Участие](#участие)
- [Оговорка](#оговорка)
- [Лицензия](#лицензия)

## Введение

Текущая редакция проекта C2y
([N3685](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3685.pdf)) содержит
спецификацию макроса `countof()` и оператора `_Countof` (технические аспекты
см. [N3369](https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3369.pdf),
названия [N3469](https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3469.htm)).
На настоящий момент, имеется две реализации этого предложения: Clang 21 и
IntelLLVM (Intel oneAPI 2025.3).

Это весьма полезная и долгожданная функция, которая позволит сделать код более
компактным, более безопасным и более удобным для сопровождения и/или
рефакторинга, подробности см. [Обоснование](#обоснование).

В рамках стандартов C/C++ макрос `countof_ns()` идентичен будущей функции
`countof()`.


## Установка

This module depends upon a knowledge of [Markdown]().

```

```

### Any optional sections

## Использование

### Использование с расширениями C/C++

`countof_ns()` так же применима, как к расширенным массивам нулевой длины, так
и к массивам содержащим расширенные объекты нулевой длины ( [пустые
структуры](https://gcc.gnu.org/onlinedocs/gcc/Empty-Structures.html),
[объединения c массивом неопределённого
размера](https://gcc.gnu.org/onlinedocs/gcc/Flexible-Array-Members-in-Unions.html)
или [структуры с единственным массивом неопределённого
размера](https://gcc.gnu.org/onlinedocs/gcc/Flexible-Array-Members-alone-in-Structures.html)). У С реализации `countof_ns()` есть одно ограничение:

```
#if !__cplusplus
    size_t a = countof_ns(int[0][0]);  // OK, =0
    size_t b = countof_ns(int[0][5]);  // OK, =0
    size_t c = countof_ns(int[5][0]);  // Compilation error
    int n = 5;
    size_t d = countof_ns(int[n][0]);  // Difference, for VLA of ZLA, return 0
#else
    static_assert(0 == countof_ns(int[0][0]));  // OK, =0
    static_assert(0 == countof_ns(int[0][5]));  // OK, =0
    static_assert(5 == countof_ns(int[5][0]));  // OK, =5
#endif
```

С++ реализация `countof_ns()` выдаёт результаты идентичные `countof()`.

## Обоснование

Во-первых, это компактно. Однако, есть ещё несколько важных причин для
использования `countof_ns()`.

### Подводные камни `sizeof()` в языке C

1. Несоответствие размерностей у числа байт и числа элементов...;

2. `sizeof()` не всегда является константным выражением. Конечно, в простейшем
   случае `const int n = 1; static_assert(0 == sizeof(int[n]));` компилятор
   сообщит об ошибке. Но в более сложных сценариях, компиляция может проходить
   без ошибок или предупреждений. А неопределённое поведение может возникать
   только уже на этапе выполнения кода;

3. `sizeof()` не всегда положителен. Весьма большое число компиляторов, по
   умолчанию поддерживают следующие расширения:
    - `static_assert(0 == sizeof(int[0]));  // C/C++, zero-length arrays`
    - `static_assert(0 == sizeof(struct{}));  // C only, empty structures`
    - `static_assert(0 == sizeof(struct{char fma[];}));  // C/C++, аlone
      flexible array member for structures or unions`
    - `int a[] = {}; static_assert(0 == sizeof(a);  // C/C++, empty initializer
      list`

Даже в случае компактного выражения вида `sizeof(a)/sizeof(*a)` компилятор не
всегда сможет выдать адекватное предупреждение в момент компиляции. А при
отсутствии стандартной функции, иногда, вычисление может оказаться разбросанным
по нескольким операторам, или может быть совмещено с другими вычислениями, что
делает задачу выдачи компилятором, хотя бы, предупреждения ещё более сложной. В
общем, всё это и послужило основанием включения функции `countof()` в проект
стандарта C2y.

### Возможные ошибки при рефакторинге

#### Изменение способа хранения и/или передачи массива

#### Изменение размерностей многомерных массивов

#### Изменение списков инициализации

### Область применения `countof_ns()` в C++

Достаточно давно, начиная с С++17 появилась функция `std::size()`. Собственно
это функция несложная и достаточно просто реализуется с помощью шаблонов C++.
Например, с ещё более давних пор, у MSVC есть её аналог: `_countof()`.

Для проектов только на C++ `std::size()` отличный инструмент, но для смешанных
C/C++ проектов он не всегда удобен. Для смешанных проектов идеально иметь
идентичный инструмент для обоих языков, например, тот же `_countof()` MSVC.

Так же, `std::size()` не очень подходит для компиляторов с поддержкой
расширения `zero-length array`, ввиду того, что реализация `countof()` для
таких массивов работает нормально, а `std::size()` выдаёт ошибку компиляции.

### Массивы VLA и стандарты C99/C11

В языке C... TODO

## Участие

PR принимаются.

Небольшое примечание: При редактировании Readme, пожалуйста, придерживайтесь
рекомендаций [standard-readme](https://github.com/RichardLitt/standard-readme).

## Оговорка

Извините, пока документ очень далёк от идеала. TODO

## Лицензия

[BSD-2-Clause © 2025 Сергей Леонтьев (leo@sai.msu.ru).](../LICENSE)
